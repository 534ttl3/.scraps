# Things I need to read and do to achieve 2d animations of simple geometriews with Panda3d

- Learn more about the *Intervals* system, which can playback scripted actinos

- Advanced operations with Panda3D's internal structures

- export .egg animations from blender and play them back in panda3d

# Panda3d internal geometry classes

Each **GeomVertex** has a position, but can also have other geometric data other associated with it, like normal vector (there's almost always redundant information, since it would suffice to define one normal vector for a plane made of 3 GeomVertex's), texcoord, color, ... , custom (whatever set of data you want to give to the shader)). For each vertex, this set of information is stored in a **GeomVertexData** object. You can modify these *column names* (see the **GeomVertexFormat** class for a list of reserved column names). 

Each **GeomVertexData** is usually a single 2d Array, stored as a contiguous
block in memory. It is also possible to distribute the data of vertices and
have different sets of columns packaged into different locations in memory.
Each of these blocks are then called **GeomVertexArray**. This is useful if you need to render multiple objects with e.g. the same geometry, but want to modify the lighting (normal) or color).

The **GeomVertexFormat** object describes how the columns of a GeomVertexData are ordered and named, and exactly what kind of numeric data is stored in each column, e.g. it gives the relatively raw data in the **GeomVertexData** objects meaning. (In practice, you first need to define a **GeomVertexFormat** to populate a **GeomVertexData** object)

**GeomVertexArrayData** contains a contiguous 2d array of data. To know how to interpret that data, a **GeomVertexArrayFormat** is needed, which contains several **GeomVertexColumn** (beware: not GeomVertexColumnFormat) objects for even more fine-grained specification of what data is in what column. 
Each **GeomVertexColumn** has a name, numeric type and contents, that are
assigned and can be queried. 

In Panda3d, to connect together vertices from a **GeomVertexArray(Data)**,
first this list of vertices is indexed and then the the indices are used to
access the vertex data. To define a primitive **GeomPrimitive** you use the
classes GeomTriangles, GeomTristrips, GeomTrifans, GeomLines, GeomLinestrips, GeomPoints, ...).

A **GeomVertexData** and several **GeomPrimitive** objects are collected to
gether to make up a **Geom** object, a single piece of renderable geomtry.
(note that the **GeomVertexFormat** objects aren't in there). 

One **GeomVertexData** may be shared among many different **Geoms** (each of
which might use a different subset of its vertices). 

A **Geom** can only have one primitive type (Tri\*, Line\*, or Points) You can call geom.getPrimitiveType() to determine the (fundamental) primitive type stored within a particular Geom. 

Conveniently named, a **GeomNode** is what pulls the **Geom** (geometry data
unattached to any scene and without rendering state) into the scene graph. Each **GeomNode** contains a list of tuples (**Geom**, **RenderState**). The **RenderState** also includes the texture image itself. These render state definitions are therefore not a seperate node, but included in the **GeomNode**, and they override any state inherited from the scene graph, unless the scene graph state definitons have a priority > 0.

A **BoundingVolume** is a piece of geometry of a node and it's children
enclosing all points down the line and is used for collision detection and
culling, it is automatically generated by Panda3D. Useful functions are
getBounds() and showBounds(). The **BoundingVolume** can be e.g. a **BoundingSphere**. Panda doesn't always compute the minimal (tight) bounds, because that would require much calculation, it often just approximates it and calculates loose bounds. You can in fact get the tightest possible box shape with getTightBounds() and show it with showTightBounds(). With setBounds(BoundingVolume(...)) and setFinal(1), you can manually assign Bounding Volumes. 

# Generating Geometry Procedurally
The first thing you need to render anything is a valid **GeomVertexFormat**,
which specifies what data you would want to give (there are pre-defined
formats which can make this task easier) to the shader/the graphics card. You need to do e.g. sth. like

```
array = GeomVertexArrayFormat()
array.addColumn("vertex", 3, Geom.NTFloat32, Geom.CPoint)
array.addColumn("texcoord", 2, Geom.NTFloat32, Geom.CTexcoord)
```

The name of a column should be an **InternalName** object (enables fast
lookups).

Pass this array to a **GeomVertexFormat**

```
format = GeomVertexFormat()
format.addArray(array)
```

Once your format is complete, register it (this is required for some internal OpenGL/DirectX configuration stuff, it might also play a role in making a proper shader that uses all the supplied data)

```
format = GeomVertexFormat.registerFormat(format)
```

The old GeomVertexFormat should be discarded once you use a new
GeomVertexFormat, so the above syntax should almost always be used. 
This seems to be a lot of overhead just to render a thing, but the *thing*'s
information must be interpreted properly and passed to the underlying API
properly, so it is necessary. The more you need to specify, the more control
you have on what actually happens. 

The pre-defined **GeomVertexFormat** that I would use in most situations is

```
format = GeomVertexFormat.getV3n3c4()    
```

You create the **GeomVertexData** by calling 

```
vdata = GeomVertexData('name', format, Geom.UHStatic)
```

where Geom.UHStatic stands for a *Usage Hint* to Panda3D, that it will be
static data (the vertices' geometry will remain unchanged). It's just a hint
though, if you want to change the actual vertex data (e.g. position) to create an animation, maybe you should give the hint Geom.UHDynamic instead (this can accellerate performance by avoiding unnecessary caching). 

Optionally, for a **GeomVertexData**, you can manually boost performance by explicitly setting the number of rows (number of vertices?) by calling ``vdata.setNumRows(4)``

To fill in the actual data tuples into the row (referring to a specific
vertex), appending it to the column, you first create for each column a
**GeomVertexWriter** object, which you then add (append) data to using
``add_ddataXX()``, e.g. 

```
vertex = GeomVertexWriter(vdata, 'vertex')
color = GeomVertexWriter(vdata, 'color')
```
and then
```
vertex.addData3f(1, 0, 0)
color.addData4f(0, 0, 1, 1)
 
vertex.addData3f(1, 1, 0)
color.addData4f(0, 0, 1, 1)
 
vertex.addData3f(0, 1, 0)
color.addData4f(0, 0, 1, 1)
 
vertex.addData3f(0, 0, 0)
color.addData4f(0, 0, 1, 1)
```

(Not in manual: There are functions like ``setRow(int row)`` and ``setDataXX()`` to access 
individual rows and columns and modify data in-place.)

To render anything, you need to instantiate a **GeomPrimitive**, and give it
the indices of the vertices to use in a particular **GeomVertexData** object. 

To draw some triangles (numbers are indices of vertices), do 

```
prim = GeomTriangles(Geom.UHStatic)
 
prim.addVertex(0)
prim.addVertex(1)
prim.addVertex(2)
# thats the first triangle
 
# you can also add a few at once
prim.addVertices(2, 1, 3)
 
prim.addVertices(0, 5, 6)
```

It is recommended, but not strictly necessary to also call ``close_primitive()``
after adding all vertices, especially for variable number of vertices
primitives e.g. for **GeomLinestrips**. You can also give a usage hint (almost
always ``Geom.UH_static``, since usually, if you intend to animate the
vertices, you would operate on the vertices, not the indices). 

There are several utility functions to add vertices by their index: 

```
add_vertices(v1, v2)
add_vertices(v1, v2, v3)
add_vertices(v1, v2, v3, v4)

add_consecutive_vertices(start, numVertices)

add_next_vertices(numVertices)
```
None of these call ``close_primitive()``, which is recommended you call
explicitly after having added all your vertices. 

To put your geometry into the scene graph, you need a **Geom** object and a
**GeomNode**.

```
geom = Geom(vdata)
geom.addPrimitive(prim)
 
node = GeomNode('gnode')
node.addGeom(geom)
 
nodePath = render.attachNewNode(node)
```

There is only one **GeomVertexData** associated with any particular **Geom**
(set it later using geom.setVertexData()).

Again: A **GeomNode** may include multiple **Geoms**, and each **Geom** may include
multiple **GeomPrimitives**. (However, all of the primitives added to a **Geom** must
have the same fundamental primitive type: triangles, lines, or points.)

-------- Editing Stuff in Blender and loading into Panda3d
    In Blender, you can install the panda3d .egg importer by downloading the repo
    at https://github.com/rdb/blender-egg-importer as .zip and going to File ->
    User Preferences -> Addons -> Install from .zip file, and activating it
    afterwards.

    The best and most famous exporter is according to panda3d.org the YABEEE
export addon, that you can download from it's github page as a .zip and then install
the addon from the file. 

    In Blender, to put the 3d cursor at blenders origin, use ``Ctrl + C``

    In Blender, to put the model's origin (yellow dot) to the position of the
    cursor, use ``Ctrl + Alt + Shift + C`` and select the appropriate option.

    In Blender, the **Pivot Point** is the Point, where the mini-3d Axes are shown. Depending on where the pivot point is, different operations  (e.g. scaling, rotating) affect the object differently.
------- 

To be able to manually position the camera using (``ShowBase.camera.setPos()``), you need to explicitly call ``self.disableMouse()`` at the beginning.

Apparently, ``prim.close_primitive()`` and ``prim.closePrimitive()`` are the
same thing. In 1.9.4, there apparently is only ``prim.closePrimitive()``. So,
if in doubt, call ``prim.closePrimitive()`` or nothing at all, since I don't
think it's necessary. 


------ Tinkering around with Inkscape 
    To make the complicated ends of latex curly brackets a path, you have to 
    ungroup (Ctrl + Shift + G) and unlink clones (Alt + Shift + D) repeatedly, 
    then you can select the nodes of the path. 
------

------ If pip2.x aka pip or pip3 is not installed: 
```
    sudo apt-get install python-pip
    sudo apt-get install python3-pip
```
------

------ Tinkering around with SVG Libraries:
    I want to render pdf (or even better svg) in panda3d
    This piece of code 
    https://discourse.panda3d.org/t/vector-graphics-on-textures-with-gizeh-cairo/15476
    caught my attention. 

    To try this out, you need **Gizeh**, a python package that depends on **Cairo**

    Before installing these, upgrade your setuptools: 
    ```
    sudo pip install --upgrade setuptools
    ```
    Then install **Cairo** and **Gizeh**
    ```
    sudo apt-get install libcairo2-dev
    sudo pip install gizeh
    ```

-----

What do I actually need now?

- From now, on creating 2d elements and animating them should pose much less of
  a problem, since I have direct access to the vertex data. 

- For videos (mp4) that explain math, I need only bitmap files (since the video
  itself is also limited in resolution). **I need a way to convert pdfs (or dvis) to
  bitmaps with transparent background.** (
  - Sympy: writes the equations to actual files with white background and black font. I'm not sure if it is also able to write to a **BytesIO**-like object, which would make it possible to
    store the files in a buffer not need to make the program write it back to the file
system (harddrive is slow). 
  - Cairo: can read in pdfs and convert them to bitmaps and even svgs (and can
    probably also calculate intermediate hermitian spline points in bezier
    curves)
  - LaTeX itself can be called from within python using a subprocess. Also,
    LaTeX integrates now a function directly, which automatically makes a call
    to convert the pdf to a png file. You then write to disk (latex file), read
    from disk (latex file), write to disk (pdf and png) and read from disk again
    (read png as texture), which may be quite expensive, but the easiest solution
    so far) 


What are putoff-tasks that would be cool but probably come with too many
difficulties ?

- putoff-task: In Panda3d itself, I don't necessarily need to store latex elements as vector
  data (that is sampled bezier curves with only straight lines connecting
nodes), I could just render all latex elements as sprites with white/colors on
transparent/halfway transparent background. Morphing sprites into other sprites
should also work (by animating the quad's corners and using double
  textures where one fades in and the other fades out)

- putoff-task: use actual vector graphics tools to render everything, like
  cairo. That would make it possible to create state machines in which you can
  navigate visually though problems, changeing interactively back and forth
  (interacting with the graphics themselves). I don't know how expensive it is to
  render animated svg graphics. 


Do 10. Mai 21:33:05 CEST 2018 
** The Next Step would be to look into Sympy rendering latex to a
semi-transparent bitmap buffer and displaying that in panda3d ** - Ok, done
that. As it turns out, it's probably easier to handle it differently. But with
some refining it may still be an option. It doesn't give you the full power of
latex though. You may not be able to play tikz images. 

----- Vim: formatting/breaking long lines 
    gq{motion} % format the line that {motion} moves over
    {Visual}gq % format the visually selected area
    gqq        % format the current line
    
    re-connect broken lines with Shift + J    
-----


Fr 18. Mai 10:16:40 CEST 2018

- scale latex textured quad to appropriate dimensions - DONE
- find a way to compile and load a latex texture procedurally, then display it

----- Matrix Representation within Panda3d differs from normal opengl/glm
    for all about panda3d's versions: 
    https://www.panda3d.org/manual/index.php/Matrix_Representation
    It appears as if p3d's Mat4 (LMatrix4f) are the transposed versions of the normal opengl/glm convention. So, you need to always transform your matrices into the right format when using i.e. pyglm. 
    The properly formatted p3d matrices for simple translation/rotation operations
    one can retrieve directly with a call to e.g. 
    ```
    static LMatrix4f translateMat   (   const LVecBase3f    trans   )   static
    ```
    (see https://www.panda3d.org/reference/1.9.4/python/panda3d.core.LMatrix4f#af0d0c9acb09597d82fa981aa804faa7a)
-----

----- Vim command to make the splits the same size
    Ctrl + W = 
-----
