# Panda3d internal geometry classes

Each **GeomVertex** has a position, but can also have other geometric data other associated with it, like normal vector (there's almost always redundant information, since it would suffice to define one normal vector for a plane made of 3 GeomVertex's), texcoord, color, ... , custom (whatever set of data you want to give to the shader)). For each vertex, this set of information is stored in a **GeomVertexData** object. You can modify these *column names* (see the **GeomVertexFormat** class for a list of reserved column names). 

Each **GeomVertexData** is usually a single 2d Array, stored as a contiguous
block in memory. It is also possible to distribute the data of vertices and
have different sets of columns packaged into different locations in memory.
Each of these blocks are then called **GeomVertexArray**. This is useful if you need to render multiple objects with e.g. the same geometry, but want to modify the lighting (normal) or color).

The **GeomVertexFormat** object describes how the columns of a GeomVertexData are ordered and named, and exactly what kind of numeric data is stored in each column, e.g. it gives the relatively raw data in the **GeomVertexData** objects meaning. (In practice, you first need to define a **GeomVertexFormat** to populate a **GeomVertexData** object)

**GeomVertexArrayData** contains a contiguous 2d array of data. To know how to interpret that data, a **GeomVertexArrayFormat** is needed, which contains several **GeomVertexColumn** (beware: not GeomVertexColumnFormat) objects for even more fine-grained specification of what data is in what column. 
Each **GeomVertexColumn** has a name, numeric type and contents, that are
assigned and can be queried. 

In Panda3d, to connect together vertices from a **GeomVertexArray(Data)**,
first this list of vertices is indexed and then the the indices are used to
access the vertex data. To define a primitive **GeomPrimitive** you use the
classes GeomTriangles, GeomTristrips, GeomTrifans, GeomLines, GeomLinestrips, GeomPoints, ...).

A **GeomVertexData** and several **GeomPrimitive** objects are collected to
gether to make up a **Geom** object, a single piece of renderable geomtry.
(note that the **GeomVertexFormat** objects aren't in there). 

One **GeomVertexData** may be shared among many different **Geoms** (each of
which might use a different subset of its vertices). 

A **Geom** can only have one primitive type (Tri\*, Line\*, or Points) You can call geom.getPrimitiveType() to determine the (fundamental) primitive type stored within a particular Geom. 

Conveniently named, a **GeomNode** is what pulls the **Geom** (geometry data
unattached to any scene and without rendering state) into the scene graph. Each **GeomNode** contains a list of tuples (**Geom**, **RenderState**). The **RenderState** also includes the texture image itself. These render state definitions are therefore not a seperate node, but included in the **GeomNode**, and they override any state inherited from the scene graph, unless the scene graph state definitons have a priority > 0.

A **BoundingVolume** is a piece of geometry of a node and it's children
enclosing all points down the line and is used for collision detection and
culling, it is automatically generated by Panda3D. Useful functions are
getBounds() and showBounds(). The **BoundingVolume** can be e.g. a **BoundingSphere**. Panda doesn't always compute the minimal (tight) bounds, because that would require much calculation, it often just approximates it and calculates loose bounds. You can in fact get the tightest possible box shape with getTightBounds() and show it with showTightBounds(). With setBounds(BoundingVolume(...)) and setFinal(1), you can manually assign Bounding Volumes. 

# Generating Geometry Procedurally
The first thing you need to render anything is a valid **GeomVertexFormat**,
which specifies what data you would want to give (there are pre-defined
formats which can make this task easier) to the shader/the graphics card. You need to do e.g. sth. like

```
array = GeomVertexArrayFormat()
array.addColumn("vertex", 3, Geom.NTFloat32, Geom.CPoint)
array.addColumn("texcoord", 2, Geom.NTFloat32, Geom.CTexcoord)
```

The name of a column should be an **InternalName** object (enables fast
lookups).

Pass this array to a **GeomVertexFormat**

```
format = GeomVertexFormat()
format.addArray(array)
```

Once your format is complete, register it (this is required for some internal OpenGL/DirectX configuration stuff, it might also play a role in making a proper shader that uses all the supplied data)

```
format = GeomVertexFormat.registerFormat(format)
```

The old GeomVertexFormat should be discarded once you use a new
GeomVertexFormat, so the above syntax should almost always be used. 
This seems to be a lot of overhead just to render a thing, but the *thing*'s
information must be interpreted properly and passed to the underlying API
properly, so it is necessary. The more you need to specify, the more control
you have on what actually happens. 

The pre-defined **GeomVertexFormat** that I would use in most situations is

```
format = GeomVertexFormat.getV3n3c4()    
```

You create the **GeomVertexDatat** by calling 

```
vdata = GeomVertexData('name', format, Geom.UHStatic)
```

where Geom.UHStatic stands for a *Usage Hint* to Panda3D, that it will be
static data (the vertices' geometry will remain unchanged). It's just a hint
though, if you want to change the actual vertex data (e.g. position) to create an animation, maybe you should give the hint Geom.UHDynamic instead (this can accellerate performance by avoiding unnecessary caching). 

Optionally, for a **GeomVertexData**, you can manually boost performance by explicitly setting the number of rows (number of vertices?) by calling ``vdata.setNumRows(4)``

To fill in the actual data tuples into the row (referring to a specific
vertex), appending it to the column, you first create for each column a
**GeomVertexWriter** object, which you then add (append) data to using
``add_ddataXX()``, e.g. 

```
vertex.addData3f(1, 0, 0)
color.addData4f(0, 0, 1, 1)
 
vertex.addData3f(1, 1, 0)
color.addData4f(0, 0, 1, 1)
 
vertex.addData3f(0, 1, 0)
color.addData4f(0, 0, 1, 1)
 
vertex.addData3f(0, 0, 0)
color.addData4f(0, 0, 1, 1)
```
